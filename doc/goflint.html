use 'godoc cmd/github.com/sourcekris/goflint' for documentation on the github.com/sourcekris/goflint command 

<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/sourcekris/goflint"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
			
				
				<dd><a href="#FlintRandT">type FlintRandT</a></dd>
				
				
			
				
				<dd><a href="#Fmpq">type Fmpq</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFmpq">func NewFmpq(p, q int64) *Fmpq</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpq.CmpRational">func (q *Fmpq) CmpRational(y *Fmpq) (r int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpq.DenRef">func (q *Fmpq) DenRef() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpq.GetFmpqFraction">func (q *Fmpq) GetFmpqFraction() (int, int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpq.MulRational">func (q *Fmpq) MulRational(o *Fmpq, x *Fmpz) *Fmpq</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpq.NumRef">func (q *Fmpq) NumRef() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpq.SetFmpqFraction">func (q *Fmpq) SetFmpqFraction(num, den *Fmpz) *Fmpq</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpq.String">func (q *Fmpq) String() string</a></dd>
				
			
				
				<dd><a href="#Fmpz">type Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFmpz">func NewFmpz(x int64) *Fmpz</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Abs">func (z *Fmpz) Abs(x *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Add">func (z *Fmpz) Add(x, y *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.AddI">func (z *Fmpz) AddI(x int) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.AddZ">func (z *Fmpz) AddZ(x *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.And">func (z *Fmpz) And(x, y *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.BitLen">func (z *Fmpz) BitLen() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Bits">func (z *Fmpz) Bits() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Bytes">func (z *Fmpz) Bytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Cmp">func (z *Fmpz) Cmp(y *Fmpz) (r int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Div">func (z *Fmpz) Div(x, y *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.DivMod">func (z *Fmpz) DivMod(x, y, m *Fmpz) (*Fmpz, *Fmpz)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.DivR">func (z *Fmpz) DivR(y, n *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Exp">func (z *Fmpz) Exp(x, y, m *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.ExpI">func (z *Fmpz) ExpI(x int) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.ExpXI">func (z *Fmpz) ExpXI(x *Fmpz, y int) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.ExpXIM">func (z *Fmpz) ExpXIM(x *Fmpz, i int, m *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.ExpXY">func (z *Fmpz) ExpXY(x, y *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.ExpZ">func (z *Fmpz) ExpZ(x *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.GCD">func (z *Fmpz) GCD(g, h *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.GCDInv">func (z *Fmpz) GCDInv(g *Fmpz) (*Fmpz, *Fmpz)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.GetInt">func (z *Fmpz) GetInt() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.GetUInt">func (z *Fmpz) GetUInt() uint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Int64">func (z *Fmpz) Int64() (y int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.IsProbabPrime">func (z *Fmpz) IsProbabPrime() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.IsProbabPrimeBPSW">func (z *Fmpz) IsProbabPrimeBPSW() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.IsProbabPrimeLucas">func (z *Fmpz) IsProbabPrimeLucas() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.IsProbabPrimePseudosquare">func (z *Fmpz) IsProbabPrimePseudosquare() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.IsStrongProbabPrime">func (z *Fmpz) IsStrongProbabPrime(a *Fmpz) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Jacobi">func (z *Fmpz) Jacobi(p *Fmpz) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Lcm">func (z *Fmpz) Lcm(g, h *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.LucasChain">func (z *Fmpz) LucasChain(v2, a, m, n *Fmpz)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Mod">func (z *Fmpz) Mod(x, y *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.ModInverse">func (z *Fmpz) ModInverse(x, y *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.ModRational">func (z *Fmpz) ModRational(x *Fmpq, n *Fmpz) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.ModZ">func (z *Fmpz) ModZ(y *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Mul">func (z *Fmpz) Mul(x, y *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.MulI">func (z *Fmpz) MulI(x int) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.MulZ">func (z *Fmpz) MulZ(x *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Neg">func (z *Fmpz) Neg(x *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.NegMod">func (z *Fmpz) NegMod(x, y *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Pow">func (z *Fmpz) Pow(x, y, m *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Quo">func (z *Fmpz) Quo(x, y *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.QuoRem">func (z *Fmpz) QuoRem(x, y, r *Fmpz) (*Fmpz, *Fmpz)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Randm">func (z *Fmpz) Randm(state *FlintRandT, m *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Root">func (z *Fmpz) Root(x *Fmpz, y int32) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Set">func (z *Fmpz) Set(x *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.SetBytes">func (z *Fmpz) SetBytes(buf []byte) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.SetInt64">func (z *Fmpz) SetInt64(x int64) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.SetMpz">func (z *Fmpz) SetMpz(x *Mpz)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.SetString">func (z *Fmpz) SetString(s string, base int) (*Fmpz, bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.SetUint64">func (z *Fmpz) SetUint64(x uint64) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Sign">func (z *Fmpz) Sign() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Sqrt">func (z *Fmpz) Sqrt(x *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.String">func (z *Fmpz) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Sub">func (z *Fmpz) Sub(x, y *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.SubI">func (z *Fmpz) SubI(x int) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.SubZ">func (z *Fmpz) SubZ(x *Fmpz) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.TstBit">func (z *Fmpz) TstBit(i int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Fmpz.Uint64">func (z *Fmpz) Uint64() (y uint64)</a></dd>
				
			
				
				<dd><a href="#FmpzMat">type FmpzMat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFmpzMat">func NewFmpzMat(rows, cols int) *FmpzMat</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FmpzMat.Entry">func (m *FmpzMat) Entry(x, y int) *Fmpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FmpzMat.NumCols">func (m *FmpzMat) NumCols() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FmpzMat.NumRows">func (m *FmpzMat) NumRows() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FmpzMat.One">func (m *FmpzMat) One() *FmpzMat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FmpzMat.Zero">func (m *FmpzMat) Zero() *FmpzMat</a></dd>
				
			
				
				<dd><a href="#MpLimb">type MpLimb</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMpLimb">func NewMpLimb(x uint64) *MpLimb</a></dd>
				
				
			
				
				<dd><a href="#Mpz">type Mpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMpz">func NewMpz(x int64) *Mpz</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mpz.Cmp">func (z *Mpz) Cmp(y *Mpz) (r int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mpz.DivMod">func (z *Mpz) DivMod(x, y, m *Mpz) (*Mpz, *Mpz)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mpz.GetMpz">func (z *Mpz) GetMpz(x *Fmpz)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mpz.MulRMpz">func (z *Mpz) MulRMpz(y, n *Mpz) *Mpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mpz.SetMpzInt64">func (z *Mpz) SetMpzInt64(x int64) *Mpz</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mpz.String">func (z *Mpz) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mpz.SubRMpz">func (z *Mpz) SubRMpz(y, n *Mpz) *Mpz</a></dd>
				
			
				
				<dd><a href="#NmodPoly">type NmodPoly</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/sourcekris/goflint/flint.go">flint.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
		
		
		
			
			
			<h2 id="FlintRandT">type <a href="/src/target/flint.go?s=1286:1344#L61">FlintRandT</a>
				<a class="permalink" href="#FlintRandT">&#xb6;</a>
			</h2>
			<p>
FlintRandT keeps state for Fmpz random number generation.
</p>

			<pre>type FlintRandT struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Fmpq">type <a href="/src/target/flint.go?s=800:846#L38">Fmpq</a>
				<a class="permalink" href="#Fmpq">&#xb6;</a>
			</h2>
			<p>
Fmpq is an arbitrary precision rational type.
</p>

			<pre>type Fmpq struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewFmpq">func <a href="/src/target/flint.go?s=4677:4707#L241">NewFmpq</a>
					<a class="permalink" href="#NewFmpq">&#xb6;</a>
				</h3>
				<pre>func NewFmpq(p, q <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Fmpq">Fmpq</a></pre>
				<p>
NewFmpq allocates and returns a new Fmpq set to p / q.
</p>

				
				
			

			
				
				<h3 id="Fmpq.CmpRational">func (*Fmpq) <a href="/src/target/flint.go?s=5812:5855#L299">CmpRational</a>
					<a class="permalink" href="#Fmpq.CmpRational">&#xb6;</a>
				</h3>
				<pre>func (q *<a href="#Fmpq">Fmpq</a>) CmpRational(y *<a href="#Fmpq">Fmpq</a>) (r <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
CmpRational compares rationals z and y and returns:
</p>
<pre>-1 if z &lt;  y
 0 if z == y
+1 if z &gt;  y
</pre>

				
				
				
			
				
				<h3 id="Fmpq.DenRef">func (*Fmpq) <a href="/src/target/flint.go?s=9305:9332#L475">DenRef</a>
					<a class="permalink" href="#Fmpq.DenRef">&#xb6;</a>
				</h3>
				<pre>func (q *<a href="#Fmpq">Fmpq</a>) DenRef() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
DenRef returns the denominator of an Fmpq as an integer.
</p>

				
				
				
			
				
				<h3 id="Fmpq.GetFmpqFraction">func (*Fmpq) <a href="/src/target/flint.go?s=8728:8771#L453">GetFmpqFraction</a>
					<a class="permalink" href="#Fmpq.GetFmpqFraction">&#xb6;</a>
				</h3>
				<pre>func (q *<a href="#Fmpq">Fmpq</a>) GetFmpqFraction() (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
GetFmpqFraction gets the integer numerator and denomenator of the rational Fmpq q.
</p>

				
				
				
			
				
				<h3 id="Fmpq.MulRational">func (*Fmpq) <a href="/src/target/flint.go?s=14489:14539#L699">MulRational</a>
					<a class="permalink" href="#Fmpq.MulRational">&#xb6;</a>
				</h3>
				<pre>func (q *<a href="#Fmpq">Fmpq</a>) MulRational(o *<a href="#Fmpq">Fmpq</a>, x *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpq">Fmpq</a></pre>
				<p>
MulRational sets q to the product of rational x and integer y and returns q.
</p>

				
				
				
			
				
				<h3 id="Fmpq.NumRef">func (*Fmpq) <a href="/src/target/flint.go?s=9150:9177#L468">NumRef</a>
					<a class="permalink" href="#Fmpq.NumRef">&#xb6;</a>
				</h3>
				<pre>func (q *<a href="#Fmpq">Fmpq</a>) NumRef() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
NumRef returns the numerator of an Fmpq as an integer.
</p>

				
				
				
			
				
				<h3 id="Fmpq.SetFmpqFraction">func (*Fmpq) <a href="/src/target/flint.go?s=5164:5216#L262">SetFmpqFraction</a>
					<a class="permalink" href="#Fmpq.SetFmpqFraction">&#xb6;</a>
				</h3>
				<pre>func (q *<a href="#Fmpq">Fmpq</a>) SetFmpqFraction(num, den *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpq">Fmpq</a></pre>
				<p>
SetFmpqFraction sets the value of q to the canonical form of
the fraction num / den and returns q.
</p>

				
				
				
			
				
				<h3 id="Fmpq.String">func (*Fmpq) <a href="/src/target/flint.go?s=7274:7304#L378">String</a>
					<a class="permalink" href="#Fmpq.String">&#xb6;</a>
				</h3>
				<pre>func (q *<a href="#Fmpq">Fmpq</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the decimal representation of z.
</p>

				
				
				
			
		
			
			
			<h2 id="Fmpz">type <a href="/src/target/flint.go?s=703:749#L32">Fmpz</a>
				<a class="permalink" href="#Fmpz">&#xb6;</a>
			</h2>
			<p>
Fmpz is a arbitrary size integer type.
</p>

			<pre>type Fmpz struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewFmpz">func <a href="/src/target/flint.go?s=4380:4407#L229">NewFmpz</a>
					<a class="permalink" href="#NewFmpz">&#xb6;</a>
				</h3>
				<pre>func NewFmpz(x <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
NewFmpz allocates and returns a new Fmpz set to x.
</p>

				
				
			

			
				
				<h3 id="Fmpz.Abs">func (*Fmpz) <a href="/src/target/flint.go?s=11516:11549#L558">Abs</a>
					<a class="permalink" href="#Fmpz.Abs">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Abs(x *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Abs sets z to |x| (the absolute value of x) and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Add">func (*Fmpz) <a href="/src/target/flint.go?s=11801:11837#L574">Add</a>
					<a class="permalink" href="#Fmpz.Add">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Add(x, y *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Add sets z to the sum x+y and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.AddI">func (*Fmpz) <a href="/src/target/flint.go?s=12154:12186#L591">AddI</a>
					<a class="permalink" href="#Fmpz.AddI">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) AddI(x <a href="/pkg/builtin/#int">int</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
AddI sets z to the sum x+z where x is an int type and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.AddZ">func (*Fmpz) <a href="/src/target/flint.go?s=11973:12007#L583">AddZ</a>
					<a class="permalink" href="#Fmpz.AddZ">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) AddZ(x *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
AddZ sets z to the sum x+z and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.And">func (*Fmpz) <a href="/src/target/flint.go?s=21912:21948#L1023">And</a>
					<a class="permalink" href="#Fmpz.And">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) And(x, y *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
And sets z = x &amp; y and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.BitLen">func (*Fmpz) <a href="/src/target/flint.go?s=7444:7471#L388">BitLen</a>
					<a class="permalink" href="#Fmpz.BitLen">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) BitLen() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
BitLen returns the length of the absolute value of z in bits.
The bit length of 0 is 0.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Bits">func (*Fmpz) <a href="/src/target/flint.go?s=26009:26034#L1120">Bits</a>
					<a class="permalink" href="#Fmpz.Bits">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Bits() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Bits returns the number of bits required to store the absolute value of z. If z is 0 then 0 is
returned.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Bytes">func (*Fmpz) <a href="/src/target/flint.go?s=11227:11256#L544">Bytes</a>
					<a class="permalink" href="#Fmpz.Bytes">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Bytes() []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>
Bytes returns the absolute value of z as a big-endian byte slice.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Cmp">func (*Fmpz) <a href="/src/target/flint.go?s=5540:5575#L283">Cmp</a>
					<a class="permalink" href="#Fmpz.Cmp">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Cmp(y *<a href="#Fmpz">Fmpz</a>) (r <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Cmp compares z and y and returns:
</p>
<pre>-1 if z &lt;  y
 0 if z == y
+1 if z &gt;  y
</pre>

				
				
				
			
				
				<h3 id="Fmpz.Div">func (*Fmpz) <a href="/src/target/flint.go?s=15762:15798#L742">Div</a>
					<a class="permalink" href="#Fmpz.Div">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Div(x, y *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Div sets z to the quotient x/y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Div implements Euclidean division (unlike Go); see DivMod for more details.
</p>

				
				
				
			
				
				<h3 id="Fmpz.DivMod">func (*Fmpz) <a href="/src/target/flint.go?s=17679:17730#L822">DivMod</a>
					<a class="permalink" href="#Fmpz.DivMod">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) DivMod(x, y, m *<a href="#Fmpz">Fmpz</a>) (*<a href="#Fmpz">Fmpz</a>, *<a href="#Fmpz">Fmpz</a>)</pre>
				<p>
DivMod sets z to the quotient x div y and m to the modulus x mod y
and returns the pair (z, m) for y != 0.
If y == 0, a division-by-zero run-time panic occurs.
</p>
<p>
DivMod implements Euclidean division and modulus (unlike Go):
</p>
<pre>q = x div y  such that
m = x - y*q  with 0 &lt;= m &lt; |q|
</pre>
<p>
(See Raymond T. Boute, &ldquo;The Euclidean definition of the functions
div and mod&rdquo;. ACM Transactions on Programming Languages and
Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992.
ACM press.)
See QuoRem for T-division and modulus (like Go).
</p>

				
				
				
			
				
				<h3 id="Fmpz.DivR">func (*Fmpz) <a href="/src/target/flint.go?s=13787:13824#L661">DivR</a>
					<a class="permalink" href="#Fmpz.DivR">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) DivR(y, n *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
DivR sets z to the result of z/y in the ring of integers(n). Currently this
only works if y fits into the int type supported by the Fmpq type.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Exp">func (*Fmpz) <a href="/src/target/flint.go?s=19197:19236#L890">Exp</a>
					<a class="permalink" href="#Fmpz.Exp">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Exp(x, y, m *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z.
If y &lt;= 0, the result is 1; if m == nil or m == 0, z = x**y.
See Knuth, volume 2, section 4.6.3.
</p>

				
				
				
			
				
				<h3 id="Fmpz.ExpI">func (*Fmpz) <a href="/src/target/flint.go?s=20650:20682#L965">ExpI</a>
					<a class="permalink" href="#Fmpz.ExpI">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) ExpI(x <a href="/pkg/builtin/#int">int</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
ExpI sets z = z**x where i is an int type and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.ExpXI">func (*Fmpz) <a href="/src/target/flint.go?s=19794:19836#L921">ExpXI</a>
					<a class="permalink" href="#Fmpz.ExpXI">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) ExpXI(x *<a href="#Fmpz">Fmpz</a>, y <a href="/pkg/builtin/#int">int</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
ExpXI sets z = x**y where u is an int type and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.ExpXIM">func (*Fmpz) <a href="/src/target/flint.go?s=20034:20086#L934">ExpXIM</a>
					<a class="permalink" href="#Fmpz.ExpXIM">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) ExpXIM(x *<a href="#Fmpz">Fmpz</a>, i <a href="/pkg/builtin/#int">int</a>, m *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
ExpXIM sets z = x**i mod m where u is an int type and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.ExpXY">func (*Fmpz) <a href="/src/target/flint.go?s=19538:19576#L907">ExpXY</a>
					<a class="permalink" href="#Fmpz.ExpXY">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) ExpXY(x, y *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
ExpXY sets z = x**y and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.ExpZ">func (*Fmpz) <a href="/src/target/flint.go?s=20411:20445#L952">ExpZ</a>
					<a class="permalink" href="#Fmpz.ExpZ">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) ExpZ(x *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
ExpZ sets z = z**x and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.GCD">func (*Fmpz) <a href="/src/target/flint.go?s=21058:21094#L987">GCD</a>
					<a class="permalink" href="#Fmpz.GCD">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) GCD(g, h *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
GCD sets f to the greatest common divisor of g and h. The result is always positive, even if
one of g and h is negative
</p>

				
				
				
			
				
				<h3 id="Fmpz.GCDInv">func (*Fmpz) <a href="/src/target/flint.go?s=21679:21724#L1010">GCDInv</a>
					<a class="permalink" href="#Fmpz.GCDInv">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) GCDInv(g *<a href="#Fmpz">Fmpz</a>) (*<a href="#Fmpz">Fmpz</a>, *<a href="#Fmpz">Fmpz</a>)</pre>
				<p>
GCDInv given integers f, g with 0 ≤ f &lt; g, computes the greatest common divisor d = gcd(f, g)
and the modular inverse a = f^-1 (mod g), whenever f != 0
void fmpz_gcdinv (fmpz_t d , fmpz_t a , const fmpz_t f , const fmpz_t g )
</p>

				
				
				
			
				
				<h3 id="Fmpz.GetInt">func (*Fmpz) <a href="/src/target/flint.go?s=7811:7838#L412">GetInt</a>
					<a class="permalink" href="#Fmpz.GetInt">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) GetInt() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
GetInt returns the value of the Fmpz type as an int type if possible.
</p>

				
				
				
			
				
				<h3 id="Fmpz.GetUInt">func (*Fmpz) <a href="/src/target/flint.go?s=7966:7995#L418">GetUInt</a>
					<a class="permalink" href="#Fmpz.GetUInt">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) GetUInt() <a href="/pkg/builtin/#uint">uint</a></pre>
				<p>
GetUInt returns the value of the Fmpz type as a uint type if possible.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Int64">func (*Fmpz) <a href="/src/target/flint.go?s=8166:8198#L425">Int64</a>
					<a class="permalink" href="#Fmpz.Int64">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Int64() (y <a href="/pkg/builtin/#int64">int64</a>)</pre>
				<p>
Int64 returns the int64 representation of z.
If z cannot be represented in an int64, the result is undefined.
</p>

				
				
				
			
				
				<h3 id="Fmpz.IsProbabPrime">func (*Fmpz) <a href="/src/target/flint.go?s=23816:23850#L1077">IsProbabPrime</a>
					<a class="permalink" href="#Fmpz.IsProbabPrime">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) IsProbabPrime() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
IsProbabPrime performs some trial division and then some probabilistic primality tests.
If z is definitely composite, the function returns 0, otherwise it is declared probably
prime, i.e. prime for most practical purposes, and the function returns 1. The chance
of declaring a composite prime is very small.
</p>

				
				
				
			
				
				<h3 id="Fmpz.IsProbabPrimeBPSW">func (*Fmpz) <a href="/src/target/flint.go?s=23391:23429#L1068">IsProbabPrimeBPSW</a>
					<a class="permalink" href="#Fmpz.IsProbabPrimeBPSW">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) IsProbabPrimeBPSW() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
IsProbabPrimeBPSW performs a Baillie-PSW probable prime test with parameters chosen by
Selfridge&#39;s method A as per [4]. Return 1 if z is a Lucas probable prime, otherwise return
0. There are no known composites passed as prime by this test, though infinitely many
probably exist. The test will declare no primes composite.
</p>

				
				
				
			
				
				<h3 id="Fmpz.IsProbabPrimeLucas">func (*Fmpz) <a href="/src/target/flint.go?s=22949:22988#L1059">IsProbabPrimeLucas</a>
					<a class="permalink" href="#Fmpz.IsProbabPrimeLucas">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) IsProbabPrimeLucas() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
IsProbabPrimeLucas performs a Lucas probable prime test with parameters chosen by Selfridge&#39;s
method A as per [4]. Return 1 if z is a Lucas probable prime, otherwise return 0. This function
declares some composites probably prime, but no primes composite.
</p>

				
				
				
			
				
				<h3 id="Fmpz.IsProbabPrimePseudosquare">func (*Fmpz) <a href="/src/target/flint.go?s=25483:25529#L1102">IsProbabPrimePseudosquare</a>
					<a class="permalink" href="#Fmpz.IsProbabPrimePseudosquare">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) IsProbabPrimePseudosquare() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
IsProbabPrimePseudosquare returns 0 is z is composite. If z is too large (greater
than about 94 bits) the function fails silently and returns −1, otherwise, if z
is proven prime by the pseudosquares method, return 1.
Tests if z is a prime according to [28, Theorem 2.7]. We first factor N using trial
division up to some limit B. In fact, the number of primes used in the trial factoring
is at most FLINT_PSEUDOSQUARES_CUTOFF.
Next we compute N/B and find the next pseudosquare Lp above this value, using a
static table as per <a href="http://research.att.com/~njas/sequences/b002189.txt">http://research.att.com/~njas/sequences/b002189.txt</a>.
As noted in the text, if p is prime then Step 3 will pass. This test rejects many
composites, and so by this time we suspect that p is prime. If N is 3 or 7 modulo 8,
we are done, and N is prime.
We now run a probable prime test, for which no known counterexamples are known, to
reject any composites. We then proceed to prove N prime by executing Step 4. In the
case that N is 1 modulo 8, if Step 4 fails, we extend the number of primes pi at Step 3
and hope to find one which passes Step 4. We take the test one past the largest p for
which we have pseudosquares Lp tabulated, as this already corresponds to the next Lp
which is bigger than 264 and hence larger than any prime we might be testing.
As explained in the text, Condition 4 cannot fail if N is prime.
The possibility exists that the probable prime test declares a composite prime. However
in that case an error is printed, as that would be of independent interest.
</p>

				
				
				
			
				
				<h3 id="Fmpz.IsStrongProbabPrime">func (*Fmpz) <a href="/src/target/flint.go?s=22547:22594#L1050">IsStrongProbabPrime</a>
					<a class="permalink" href="#Fmpz.IsStrongProbabPrime">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) IsStrongProbabPrime(a *<a href="#Fmpz">Fmpz</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>
IsStrongProbabPrime returns 1 if z is a strong probable prime to base a, otherwise it returns 0
</p>

				
				
				
			
				
				<h3 id="Fmpz.Jacobi">func (*Fmpz) <a href="/src/target/flint.go?s=18907:18941#L880">Jacobi</a>
					<a class="permalink" href="#Fmpz.Jacobi">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Jacobi(p *<a href="#Fmpz">Fmpz</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Jacobi computes the Jacobi symbol of a modulo p, where p is a prime and a is reduced modulo p
</p>

				
				
				
			
				
				<h3 id="Fmpz.Lcm">func (*Fmpz) <a href="/src/target/flint.go?s=21314:21350#L998">Lcm</a>
					<a class="permalink" href="#Fmpz.Lcm">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Lcm(g, h *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Lcm sets f to the least common multiple of g and h. The result is always nonnegative, even
if one of g and h is negative.
</p>

				
				
				
			
				
				<h3 id="Fmpz.LucasChain">func (*Fmpz) <a href="/src/target/flint.go?s=25715:25759#L1109">LucasChain</a>
					<a class="permalink" href="#Fmpz.LucasChain">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) LucasChain(v2, a, m, n *<a href="#Fmpz">Fmpz</a>)</pre>
				<p>
LucasChain Given V0 = 2, V1 = A compute Vm, Vm+1 (mod n) from the recurrences Vj = AVj−1 −
Vj−2 (mod n).
</p>

				
				
				
			
				
				<h3 id="Fmpz.Mod">func (*Fmpz) <a href="/src/target/flint.go?s=16532:16568#L780">Mod</a>
					<a class="permalink" href="#Fmpz.Mod">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Mod(x, y *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Mod sets z to the modulus x%y for y != 0 and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.ModInverse">func (*Fmpz) <a href="/src/target/flint.go?s=18472:18515#L860">ModInverse</a>
					<a class="permalink" href="#Fmpz.ModInverse">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) ModInverse(x, y *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
ModInverse sets z to the inverse of x modulo y and returns z.
The value of y may not be 0 otherwise an exception results. If the
inverse exists the return value will be non-zero, otherwise the return value
will be 0 and the value of f undefined.
</p>

				
				
				
			
				
				<h3 id="Fmpz.ModRational">func (*Fmpz) <a href="/src/target/flint.go?s=16957:17005#L800">ModRational</a>
					<a class="permalink" href="#Fmpz.ModRational">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) ModRational(x *<a href="#Fmpq">Fmpq</a>, n *<a href="#Fmpz">Fmpz</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>
ModRational sets z to the residue of x = n/d (num, den) modulo n and
returns 1 if such a residue exists otherwise 0.
</p>

				
				
				
			
				
				<h3 id="Fmpz.ModZ">func (*Fmpz) <a href="/src/target/flint.go?s=16720:16754#L790">ModZ</a>
					<a class="permalink" href="#Fmpz.ModZ">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) ModZ(y *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
ModZ sets z to the modulus z%y for y != 0 and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Mul">func (*Fmpz) <a href="/src/target/flint.go?s=12882:12918#L624">Mul</a>
					<a class="permalink" href="#Fmpz.Mul">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Mul(x, y *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Mul sets z to the product x*y and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.MulI">func (*Fmpz) <a href="/src/target/flint.go?s=13258:13290#L642">MulI</a>
					<a class="permalink" href="#Fmpz.MulI">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) MulI(x <a href="/pkg/builtin/#int">int</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
MulI sets z to the product of z  * x where x is an int type
and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.MulZ">func (*Fmpz) <a href="/src/target/flint.go?s=13064:13098#L633">MulZ</a>
					<a class="permalink" href="#Fmpz.MulZ">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) MulZ(x *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
MulZ sets z to the product of z  * x and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Neg">func (*Fmpz) <a href="/src/target/flint.go?s=11654:11687#L566">Neg</a>
					<a class="permalink" href="#Fmpz.Neg">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Neg(x *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Neg sets z to -x and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.NegMod">func (*Fmpz) <a href="/src/target/flint.go?s=18676:18715#L870">NegMod</a>
					<a class="permalink" href="#Fmpz.NegMod">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) NegMod(x, y *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
NegMod Sets z to −x (mod y), assuming x is reduced modulo y.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Pow">func (*Fmpz) <a href="/src/target/flint.go?s=20829:20868#L977">Pow</a>
					<a class="permalink" href="#Fmpz.Pow">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Pow(x, y, m *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Pow is a wrapper for Exp.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Quo">func (*Fmpz) <a href="/src/target/flint.go?s=14836:14872#L710">Quo</a>
					<a class="permalink" href="#Fmpz.Quo">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Quo(x, y *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Quo sets z to the quotient x/y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Quo implements truncated division (like Go); see QuoRem for more details.
</p>

				
				
				
			
				
				<h3 id="Fmpz.QuoRem">func (*Fmpz) <a href="/src/target/flint.go?s=15397:15448#L730">QuoRem</a>
					<a class="permalink" href="#Fmpz.QuoRem">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) QuoRem(x, y, r *<a href="#Fmpz">Fmpz</a>) (*<a href="#Fmpz">Fmpz</a>, *<a href="#Fmpz">Fmpz</a>)</pre>
				<p>
QuoRem sets z to the quotient x/y and r to the remainder x%y
and returns the pair (z, r) for y != 0.
If y == 0, a division-by-zero run-time panic occurs.
</p>
<p>
QuoRem implements T-division and modulus (like Go):
</p>
<pre>q = x/y      with the result truncated to zero
r = x - y*q
</pre>
<p>
(See Daan Leijen, &ldquo;Division and Modulus for Computer Scientists&rdquo;.)
See DivMod for Euclidean division and modulus (unlike Go).
</p>

				
				
				
			
				
				<h3 id="Fmpz.Randm">func (*Fmpz) <a href="/src/target/flint.go?s=26348:26402#L1134">Randm</a>
					<a class="permalink" href="#Fmpz.Randm">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Randm(state *<a href="#FlintRandT">FlintRandT</a>, m *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Randm sets z to a random integer between 0 and m-1 inclusive.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Root">func (*Fmpz) <a href="/src/target/flint.go?s=22279:22322#L1040">Root</a>
					<a class="permalink" href="#Fmpz.Root">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Root(x *<a href="#Fmpz">Fmpz</a>, y <a href="/pkg/builtin/#int32">int32</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Root sets x to the truncated integer part of the yth root of x
</p>

				
				
				
			
				
				<h3 id="Fmpz.Set">func (*Fmpz) <a href="/src/target/flint.go?s=5335:5368#L269">Set</a>
					<a class="permalink" href="#Fmpz.Set">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Set(x *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Set sets z to x and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.SetBytes">func (*Fmpz) <a href="/src/target/flint.go?s=10922:10963#L529">SetBytes</a>
					<a class="permalink" href="#Fmpz.SetBytes">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) SetBytes(buf []<a href="/pkg/builtin/#byte">byte</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
SetBytes interprets buf as the bytes of a big-endian unsigned
integer, sets z to that value, and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.SetInt64">func (*Fmpz) <a href="/src/target/flint.go?s=4062:4100#L213">SetInt64</a>
					<a class="permalink" href="#Fmpz.SetInt64">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) SetInt64(x <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
SetInt64 sets z to x and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.SetMpz">func (*Fmpz) <a href="/src/target/flint.go?s=10577:10606#L512">SetMpz</a>
					<a class="permalink" href="#Fmpz.SetMpz">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) SetMpz(x *<a href="#Mpz">Mpz</a>)</pre>
				<p>
SetMpz transform x into an Fmpz z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.SetString">func (*Fmpz) <a href="/src/target/flint.go?s=9919:9977#L490">SetString</a>
					<a class="permalink" href="#Fmpz.SetString">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) SetString(s <a href="/pkg/builtin/#string">string</a>, base <a href="/pkg/builtin/#int">int</a>) (*<a href="#Fmpz">Fmpz</a>, <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetString sets z to the value of s, interpreted in the given base,
and returns z and a boolean indicating success. If SetString fails,
the value of z is undefined but the returned value is nil.
</p>
<p>
The base argument must be 0 or a value from 2 through MaxBase. If the base
is 0, the string prefix determines the actual conversion base. A prefix of
&ldquo;0x&rdquo; or &ldquo;0X&rdquo; selects base 16; the &ldquo;0&rdquo; prefix selects base 8, and a
&ldquo;0b&rdquo; or &ldquo;0B&rdquo; prefix selects base 2. Otherwise the selected base is 10.
</p>

				
				
				
			
				
				<h3 id="Fmpz.SetUint64">func (*Fmpz) <a href="/src/target/flint.go?s=3911:3951#L205">SetUint64</a>
					<a class="permalink" href="#Fmpz.SetUint64">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) SetUint64(x <a href="/pkg/builtin/#uint64">uint64</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
SetUint64 sets z to x and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Sign">func (*Fmpz) <a href="/src/target/flint.go?s=7640:7665#L402">Sign</a>
					<a class="permalink" href="#Fmpz.Sign">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Sign() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Sign returns:
</p>
<pre>-1 if x &lt;  0
 0 if x == 0
+1 if x &gt;  0
</pre>

				
				
				
			
				
				<h3 id="Fmpz.Sqrt">func (*Fmpz) <a href="/src/target/flint.go?s=22108:22142#L1032">Sqrt</a>
					<a class="permalink" href="#Fmpz.Sqrt">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Sqrt(x *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Sqrt sets x to the truncated integer part of the square root of x
</p>

				
				
				
			
				
				<h3 id="Fmpz.String">func (*Fmpz) <a href="/src/target/flint.go?s=7166:7196#L373">String</a>
					<a class="permalink" href="#Fmpz.String">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the decimal representation of z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Sub">func (*Fmpz) <a href="/src/target/flint.go?s=12336:12372#L599">Sub</a>
					<a class="permalink" href="#Fmpz.Sub">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Sub(x, y *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Sub sets z to the difference x-y and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.SubI">func (*Fmpz) <a href="/src/target/flint.go?s=12703:12735#L616">SubI</a>
					<a class="permalink" href="#Fmpz.SubI">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) SubI(x <a href="/pkg/builtin/#int">int</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
SubI sets z to the difference z-x where x is an int type and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.SubZ">func (*Fmpz) <a href="/src/target/flint.go?s=12515:12549#L608">SubZ</a>
					<a class="permalink" href="#Fmpz.SubZ">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) SubZ(x *<a href="#Fmpz">Fmpz</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
SubZ sets z to the difference z-x and returns z.
</p>

				
				
				
			
				
				<h3 id="Fmpz.TstBit">func (*Fmpz) <a href="/src/target/flint.go?s=26151:26183#L1126">TstBit</a>
					<a class="permalink" href="#Fmpz.TstBit">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) TstBit(i <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>
TstBit tests bit index i of z and return 0 or 1, accordingly.
</p>

				
				
				
			
				
				<h3 id="Fmpz.Uint64">func (*Fmpz) <a href="/src/target/flint.go?s=8501:8535#L441">Uint64</a>
					<a class="permalink" href="#Fmpz.Uint64">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Fmpz">Fmpz</a>) Uint64() (y <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
				<p>
Uint64 returns the uint64 representation of z.
If z cannot be represented in a uint64, the result is undefined.
</p>

				
				
				
			
		
			
			
			<h2 id="FmpzMat">type <a href="/src/target/flint.go?s=1378:1451#L67">FmpzMat</a>
				<a class="permalink" href="#FmpzMat">&#xb6;</a>
			</h2>
			<p>
FmpzMat is a matrix of Fmpz.
</p>

			<pre>type FmpzMat struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewFmpzMat">func <a href="/src/target/flint.go?s=4515:4555#L234">NewFmpzMat</a>
					<a class="permalink" href="#NewFmpzMat">&#xb6;</a>
				</h3>
				<pre>func NewFmpzMat(rows, cols <a href="/pkg/builtin/#int">int</a>) *<a href="#FmpzMat">FmpzMat</a></pre>
				<p>
NewFmpzMat allocates a rows * cols matrix and returns a new FmpzMat.
</p>

				
				
			

			
				
				<h3 id="FmpzMat.Entry">func (*FmpzMat) <a href="/src/target/flint.go?s=27132:27171#L1168">Entry</a>
					<a class="permalink" href="#FmpzMat.Entry">&#xb6;</a>
				</h3>
				<pre>func (m *<a href="#FmpzMat">FmpzMat</a>) Entry(x, y <a href="/pkg/builtin/#int">int</a>) *<a href="#Fmpz">Fmpz</a></pre>
				<p>
Entry returns the value at x, y in the matrix m and returns it.
</p>

				
				
				
			
				
				<h3 id="FmpzMat.NumCols">func (*FmpzMat) <a href="/src/target/flint.go?s=26989:27020#L1163">NumCols</a>
					<a class="permalink" href="#FmpzMat.NumCols">&#xb6;</a>
				</h3>
				<pre>func (m *<a href="#FmpzMat">FmpzMat</a>) NumCols() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
NumCols returns the number of cols in a FmpzMat matrix.
</p>

				
				
				
			
				
				<h3 id="FmpzMat.NumRows">func (*FmpzMat) <a href="/src/target/flint.go?s=26854:26885#L1158">NumRows</a>
					<a class="permalink" href="#FmpzMat.NumRows">&#xb6;</a>
				</h3>
				<pre>func (m *<a href="#FmpzMat">FmpzMat</a>) NumRows() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
NumRows returns the number of rows in a FmpzMat matrix.
</p>

				
				
				
			
				
				<h3 id="FmpzMat.One">func (*FmpzMat) <a href="/src/target/flint.go?s=26722:26754#L1152">One</a>
					<a class="permalink" href="#FmpzMat.One">&#xb6;</a>
				</h3>
				<pre>func (m *<a href="#FmpzMat">FmpzMat</a>) One() *<a href="#FmpzMat">FmpzMat</a></pre>
				<p>
One sets diagonal values of matrix m to 1 and returns m.
</p>

				
				
				
			
				
				<h3 id="FmpzMat.Zero">func (*FmpzMat) <a href="/src/target/flint.go?s=26587:26620#L1146">Zero</a>
					<a class="permalink" href="#FmpzMat.Zero">&#xb6;</a>
				</h3>
				<pre>func (m *<a href="#FmpzMat">FmpzMat</a>) Zero() *<a href="#FmpzMat">FmpzMat</a></pre>
				<p>
Zero sets all values of matrix m to zero and returns m.
</p>

				
				
				
			
		
			
			
			<h2 id="MpLimb">type <a href="/src/target/flint.go?s=1186:1223#L56">MpLimb</a>
				<a class="permalink" href="#MpLimb">&#xb6;</a>
			</h2>
			<p>
MpLimb type is a mp_limb_t which is a type alias for ulong which in go is a uint64.
</p>

			<pre>type MpLimb struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewMpLimb">func <a href="/src/target/flint.go?s=4989:5021#L256">NewMpLimb</a>
					<a class="permalink" href="#NewMpLimb">&#xb6;</a>
				</h3>
				<pre>func NewMpLimb(x <a href="/pkg/builtin/#uint64">uint64</a>) *<a href="#MpLimb">MpLimb</a></pre>
				<p>
NewMpLimb returns a new MpLimb type from a uint64.
</p>

				
				
			

			
		
			
			
			<h2 id="Mpz">type <a href="/src/target/flint.go?s=925:969#L44">Mpz</a>
				<a class="permalink" href="#Mpz">&#xb6;</a>
			</h2>
			<p>
Mpz is an abitrary size integer type from the Gnu Multiprecision Library.
</p>

			<pre>type Mpz struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewMpz">func <a href="/src/target/flint.go?s=4872:4897#L251">NewMpz</a>
					<a class="permalink" href="#NewMpz">&#xb6;</a>
				</h3>
				<pre>func NewMpz(x <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Mpz">Mpz</a></pre>
				<p>
NewMpz allocates and returns a new Fmpz set to x.
</p>

				
				
			

			
				
				<h3 id="Mpz.Cmp">func (*Mpz) <a href="/src/target/flint.go?s=6086:6119#L315">Cmp</a>
					<a class="permalink" href="#Mpz.Cmp">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Mpz">Mpz</a>) Cmp(y *<a href="#Mpz">Mpz</a>) (r <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Cmp compares Mpz z and y and returns:
</p>
<pre>-1 if z &lt;  y
 0 if z == y
+1 if z &gt;  y
</pre>

				
				
				
			
				
				<h3 id="Mpz.DivMod">func (*Mpz) <a href="/src/target/flint.go?s=16127:16174#L759">DivMod</a>
					<a class="permalink" href="#Mpz.DivMod">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Mpz">Mpz</a>) DivMod(x, y, m *<a href="#Mpz">Mpz</a>) (*<a href="#Mpz">Mpz</a>, *<a href="#Mpz">Mpz</a>)</pre>
				<p>
DivMod sets z to the quotient x div y and m to the modulus x mod y
and returns the pair (z, m) for y != 0.
</p>

				
				
				
			
				
				<h3 id="Mpz.GetMpz">func (*Mpz) <a href="/src/target/flint.go?s=10711:10740#L520">GetMpz</a>
					<a class="permalink" href="#Mpz.GetMpz">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Mpz">Mpz</a>) GetMpz(x *<a href="#Fmpz">Fmpz</a>)</pre>
				<p>
GetMpz transform x into an Mpz z.
</p>

				
				
				
			
				
				<h3 id="Mpz.MulRMpz">func (*Mpz) <a href="/src/target/flint.go?s=13476:13513#L651">MulRMpz</a>
					<a class="permalink" href="#Mpz.MulRMpz">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Mpz">Mpz</a>) MulRMpz(y, n *<a href="#Mpz">Mpz</a>) *<a href="#Mpz">Mpz</a></pre>
				<p>
MulRMpz sets z to the product of z and y modulo n and returns z using Mpz
types.
</p>

				
				
				
			
				
				<h3 id="Mpz.SetMpzInt64">func (*Mpz) <a href="/src/target/flint.go?s=4214:4253#L221">SetMpzInt64</a>
					<a class="permalink" href="#Mpz.SetMpzInt64">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Mpz">Mpz</a>) SetMpzInt64(x <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Mpz">Mpz</a></pre>
				<p>
SetMpzInt64 sets z to x and returns z.
</p>

				
				
				
			
				
				<h3 id="Mpz.String">func (*Mpz) <a href="/src/target/flint.go?s=7059:7088#L368">String</a>
					<a class="permalink" href="#Mpz.String">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Mpz">Mpz</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
String returns the decimal representation of z.
</p>

				
				
				
			
				
				<h3 id="Mpz.SubRMpz">func (*Mpz) <a href="/src/target/flint.go?s=14217:14254#L688">SubRMpz</a>
					<a class="permalink" href="#Mpz.SubRMpz">&#xb6;</a>
				</h3>
				<pre>func (z *<a href="#Mpz">Mpz</a>) SubRMpz(y, n *<a href="#Mpz">Mpz</a>) *<a href="#Mpz">Mpz</a></pre>
				<p>
SubRMpz sets z to the z -y modulo n and returns z using Mpz
types.
</p>

				
				
				
			
		
			
			
			<h2 id="NmodPoly">type <a href="/src/target/flint.go?s=1042:1097#L50">NmodPoly</a>
				<a class="permalink" href="#NmodPoly">&#xb6;</a>
			</h2>
			<p>
NmodPoly type represents elements of Z/nZ[x] for a fixed modulus n.
</p>

			<pre>type NmodPoly struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	


	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="..">..</a></td>
			</tr>
			

			
				
					<tr>
						<td class="pkg-name" style="padding-left: 0px;">
							<a href="doc/">doc</a>
						</td>
						<td class="pkg-synopsis">
							
						</td>
					</tr>
				
			
		</table>
	</div>


	

